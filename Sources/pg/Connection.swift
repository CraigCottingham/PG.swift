import Foundation


/// The underlying connection to a Postgre server
///
/// You do not normally interact with a connection directly, but instead use `Client` to manage the interaction. This class only handles the low level messages between the client and the server.
public final class Connection {
	/// Errors generated by the connection
	///
	/// - mismatchedDataLengths: The server did not respond with the amount of data is said it would. This is a serious connection error and should result in a disconnect, because it is likely the client and server have gotten out of sync.
	/// - unrecognizedMessage: The server sent a message that the client did not recognize. This is likely an unimplimented feature and can be ignored. The connection will skip the message and move on.
	/// - malformedMessage: The message type was understood, but the message was in a format that the connection did not understand. This should be rare.
	public enum Error: Swift.Error {
		case mismatchedDataLengths
		case unrecognizedMessage(UInt8)
		case malformedMessage
	}
	
	
	/// Incoming/backend message types
	///
	/// Postgre messages (almost) always start with a single byte indicating what type of message they are. The documentation refer to these by their ASCII character. The rawValue is the ASCII code point.
	///
	/// See https://www.postgresql.org/docs/devel/static/protocol-message-formats.html.
	public enum BackendMessageType: UInt8 {
		case authentication = 82 // R
		case statusReport = 83 // S
		case backendKeyData = 75 // K
		case readyForQuery = 90 // Z
		case rowDescription = 84 // T
		case commandComplete = 67 // C
		case dataRow = 68 // D
		
		case parseComplete = 49 // 1
		case bindComplete = 50 // 2
		
		case errorResponse = 69 // E
	}
	
	/// Outgoing/frontend message types
	///
	/// Postgre messages (almost) always start with a single byte indicating what type of message they are. The documentation refer to these by their ASCII character. The rawValue is the ASCII code point.
	///
	/// See https://www.postgresql.org/docs/devel/static/protocol-message-formats.html.
	public enum FrontendMessageType: UInt8 {
		case startup // the only message that doesn't announce it's type
		
		case simpleQuery = 81 // Q
		case parseQuery = 80 // P
		case bind = 66 // B
		case describe = 68 // D
		case execute = 69 // E
		
		case sync = 83 // S
	}
	
	/// Types of authentication requests
	///
	/// - authenticationOK: Sent when the conneciton is authenticated.
	public enum AuthenticationResponse: UInt32 {
		case authenticationOK = 0
		// case kerberosV5 = 2
		// case cleartextPassword = 3
		// case MD5Password = 5
		// case SCMCredential = 6
	}
	
	/// The query state of the connection
	///
	/// The documentation refer to these by their ASCII character. The rawValue is the ASCII code point.
	///
	/// - notReady: Either the connection has not been established or the connection is currently excecuting a query. The server does not tell us this state, instead we need to set it locally before excecuting a query.
	/// - idle: The server is ready to receive a new query.
	/// - inTransaction: The server is in the middle of a transaction.
	/// - failed: An error occured in a transaction.
	public enum TransactionStatus: UInt8 {
		case notReady
		
		case idle = 73 // I - not in a transaction block
		case inTransaction = 84 // T
		case failed = 69 // E
	}
	
	
	// MARK: - Events
	
	/// Emitted when the connection is established with the server
	public let connected = EventEmitter<Void>(name: "PG.Connection.connected")
	/// Emitted when the connection has authenticated.
	public let loginSuccess = EventEmitter<Void>(name: "PG.Connection.loginSuccess")
	
	
	/// Emitted when a ready for query notification is receieved.
	///
	/// - Note: Note this does not necessarily mean the connection is idle.
	public let readyForQuery = EventEmitter<TransactionStatus>(name: "PG.Connection.readyForQuery")
	
	
	/// Emitted when a row description (the list of field types) is recieved.
	///
	/// This should be sent once per fetch query.
	public let rowDescriptionReceived = EventEmitter<[Field]>(name: "PG.Connection.rowDescriptionReceived")
	
	/// Emitted when a single row is received
	///
	/// This should be sent for each row in a SELECT result.
	public let rowReceived = EventEmitter<[DataSlice?]>(name: "PG.Connection.rowReceived")
	
	/// Emitted when a query has completed processing
	///
	/// Includes the type and result of the query.
	public let commandComplete = EventEmitter<String>(name: "PG.Connection.commandComplete")
	
	/// Emitted when a prepared statement is processed
	///
	/// - Note: parse complete is only sent from the server after a sync or an excecute call.
	public let parseComplete = EventEmitter<Void>(name: "PG.Connection.parseComplete")
	
	/// Emitted when a bind call is completed by the server
	///
	/// - Note: parse complete is only sent from the server after a sync or an excecute call.
	public let bindComplete = EventEmitter<Void>(name: "PG.Connection.bindComplete")
	
	
	/// Emitted when the server sends an error message
	public let errorResponse = EventEmitter<ServerError>(name: "PG.Connection.errorResponse")
	
	/// Emitted when any error occurs, including and error response
	public let error = EventEmitter<Swift.Error>(name: "PG.Connection.error")
	
	
	// MARK: - Initialization
	
	private let queue = DispatchQueue(label: "PG.Connection", qos: .userInteractive)
	
	
	/// The underlying socket connection
	public let socket: Socket
	
	
	/// Create a new connection
	///
	/// The streams should be ready for connection, and they should be opened immediately after the connection is created.
	///
	/// - Parameters:
	///   - input: An input stream ready for connection
	///   - output: An output stream ready for connection
	init(socket: Socket) {
		self.socket = socket
		
		// start reading messages
		self.read()
	}
	
	
	// MARK: - 
	
	/// If the connection has been established
	public var isConnected: Bool {
		return socket.isConnected
	}
	
	/// If the connection has been authenticated with the server
	public private(set) var isAuthenticated: Bool = false
	
	/// Server defined configuration parameters, such as text encoding and date format
	public private(set) var parameters: [String:String] = [:]
	
	/// The process id of the connection, used to cancel queries
	public private(set) var processID: Int32?
	
	/// The secret key of the connection, used to cancel queries
	public private(set) var secretKey: Int32?
	
	/// The state of the server to accept queries
	public fileprivate(set) var transactionStatus: TransactionStatus = .notReady
	
	
	// MARK: - Writing
	
	/// Send a message to the server
	///
	/// - Parameters:
	///   - type: The type of message to write
	///   - buffer: The body of the message
	///   - completion: Called when the message has been written
	func write(_ type: FrontendMessageType, _ buffer: WriteBuffer, completion: (() -> Void)? = nil) {
		queue.async {
			if type != .startup {
				self.socket.write(data: Data(bytesFrom: type.rawValue), completion: nil)
			}
			
			self.socket.write(data: Data(bytesFrom: UInt32(buffer.data.count + 4)), completion: nil)
			
			self.socket.write(data: buffer.data, completion: { 
				completion?()
			})
		}
	}
	
	
	// MARK: - Reading
	
	/// Try to read the next message
	private func read() {
		// because the socket reads new bytes asynchronously, we can just ask it to call us back once it's read in 5 bytes (header size of a pg message)
		// once the server sends the socket data, it will read in the number of bytes we ask for and call us back
		// ince we finish reading in a message, we can ask for the next one and the process starts over
		
		socket.read(length: 1 + 4) { (messageHeader) in
			do {
				var headerBuffer = ReadBuffer(messageHeader)
				
				let byte: UInt8 = try headerBuffer.read()
				let length: UInt32 = try headerBuffer.read() - 4
				
				self.socket.read(length: Int(length)) { data in
					self.queue.async {
						do {
							guard let messageType = BackendMessageType(rawValue: byte) else {
								throw Error.unrecognizedMessage(byte)
							}
							
							try self.process(messageType, from: data)
						} catch {
							// this probably isn't a fatal error
							print("error processing message: \(error)")
						}
					}
					
					// we don't need to wait for the message to be processed before reading the next message
					// since we have already read all the data for the current message
					self.read()
				}
			} catch {
				self.error.emit(error)
				print("error reading message header: \(error)")
				
				// TODO: this should probably be a disconnect
				self.read()
			}
		}
	}
	
	private func process(_ message: BackendMessageType, from data: Data) throws {
		if #available(OSX 10.12, *) {
			dispatchPrecondition(condition: .onQueue(self.queue))
		}
		
		var buffer = ReadBuffer(data)
		print("processing: \(message)")
		
		switch message {
		case .authentication:
			let rawResponse: UInt32 = try buffer.read()
			
			if let response = AuthenticationResponse(rawValue: rawResponse) {
				switch response {
				case .authenticationOK:
					self.isAuthenticated = true
					self.loginSuccess.emit()
				}
			} else {
				
			}
		case .statusReport:
			let key: String = try buffer.read()
			let value: String = try buffer.read()
			
			parameters[key] = value
			
			print("status \(key): \(value)")
		case .backendKeyData:
			guard buffer.data.count == 8 else { throw Error.malformedMessage }
			self.processID = try buffer.read()
			self.secretKey = try buffer.read()
			
			print("processID: \(processID!) secretKey: \(secretKey!)")
		case .readyForQuery:
			guard buffer.data.count == 1 else { throw Error.malformedMessage }
			
			let rawStatus: UInt8 = try buffer.read()
			self.transactionStatus = TransactionStatus(rawValue: rawStatus) ?? .idle
			
			self.readyForQuery.emit(self.transactionStatus)
		case .rowDescription:
			let fieldsCount: UInt16 = try buffer.read()
			
			let fields: [Field] = try (0..<fieldsCount).map() { _ in
				let field = Field()
				field.name = try buffer.read()
				field.tableID = try buffer.read()
				field.columnID = try buffer.read()
				field.dataTypeID = try OID(buffer.read())
				field.dataTypeSize = try buffer.read()
				field.dataTypeModifier = try buffer.read()
				field.mode = try Field.Mode(rawValue: buffer.read()) ?? .text
				return field
			}
			
			self.rowDescriptionReceived.emit(fields)
			print("fields: \(fields)")
		case .commandComplete:
			let commandTag = try buffer.read() as String
			print("command complete: \(commandTag)")
			
			self.commandComplete.emit(commandTag)
		case .dataRow:
			let columnCount = try buffer.read() as UInt16
			
			let rows: [DataSlice?] = try (0..<columnCount).map() { _ in
				let length = try buffer.read() as Int32
				print("length: \(length)")
				if length >= 0 {
					return try buffer.read(length: Int(length))
				} else {
					return nil
				}
			}
			
			self.rowReceived.emit(rows)
		case .parseComplete:
			guard buffer.data.count == 0 else { throw Error.malformedMessage }
			
			parseComplete.emit()
		case .bindComplete:
			guard buffer.data.count == 0 else { throw Error.malformedMessage }
			
			bindComplete.emit()
		case .errorResponse:
			var error = ServerError()
			while buffer.data.count > 0 {
				let fieldType = try buffer.read() as UInt8
				guard fieldType != 0 else { break }
				
				guard let field = ServerError.Field(rawValue: fieldType) else { continue }
				let value = try buffer.read() as String
				
				error.info.append((field, value))
			}
			print("error: \(error)")
			
			self.errorResponse.emit(error)
			self.error.emit(error)
		}
	}
}

extension Connection {
	/// Send the initial startup message to the server
	///
	/// - Parameters:
	///   - user: The username for the connection
	///   - database: The database, or nil to connect to the default database
	func sendStartup(user: String, database: String?) {
		var message = WriteBuffer()
		
		// protocol version
		message.write(3 as Int16)
		message.write(0 as Int16)
		
		message.write("user")
		message.write(user)
		
		if let database = database {
			print("database: \(database)")
			message.write("database")
			message.write(database)
		}
		
		message.write("client_encoding")
		message.write("'utf-8'")
		
		message.write("")
		
		self.write(.startup, message)
	}
	
	
	/// Excecute a simple query without any bindings
	///
	/// If a query is not going to be prepared and reused, and doesn't have bindings, it can be excecuted faster using a single message instead of the more complicated extended flow.
	///
	/// - Parameter query: A simple query string.
	func simpleQuery(_ query: String) {
		self.transactionStatus = .notReady
		
		var message = WriteBuffer()
		message.write(query)
		
		self.write(.simpleQuery, message)
	}
	
	/// Prepare a statement with the server
	///
	/// - Parameters:
	///   - name: The name of the statement, or an empty string to use the implicit statement
	///   - query: The query string to prepare, with `$x` for binding placehoders
	///   - types: The low level type ids for the query. Use 0 to not specifiy a type.
	func parse(name: String = "", query: String, types: [OID] = []) {
		self.transactionStatus = .notReady
		
		var message = WriteBuffer()
		
		message.write(name)
		message.write(query)
		message.write(UInt16(types.count))
		for type in types {
			message.write(type.rawValue)
		}
		
		self.write(.parseQuery, message)
	}
	
	/// Bind a statement with specific values
	///
	/// - Parameters:
	///   - name: The name of the "portal" (a bound statement) or an empty string to use the implicit portal.
	///   - statementName: The name of the statement to bind to, or an empty string to use the implicit statement.
	///   - parameters: The specific values to bind to. These must matcht the types of the statement.
	func bind(name: String = "", statementName: String = "", parameters: [PostgresRepresentable?] = []) {
		self.transactionStatus = .notReady
		
		var message = WriteBuffer()
		
		message.write(name)
		message.write(statementName)
		
		message.write(UInt16(parameters.count))
		for _ in parameters {
			message.write(UInt16(Field.Mode.text.rawValue)) // TODO: select best format
		}
		
		message.write(UInt16(parameters.count))
		for parameter in parameters {
			if let parameter = parameter, let text = parameter.pgText {
				let data = text.data()
				message.write(Int32(data.count))
				message.write(data)
			} else {
				message.write(Int16(-1)) // null
			}
		}
		
		message.write(UInt16(0))
		
		self.write(.bind, message)
	}
	
	/// Describe a prepared statement
	///
	/// - Parameter name: The name of the statement to bind to, or an empty string to use the implicit statement.
	func describeStatement(name: String = "") {
		self.transactionStatus = .notReady
		
		var message = WriteBuffer()
		
		message.write(Int8(83))
		message.write(name)
		
		self.write(.describe, message)
	}
	
	/// Describe a prepared portal (bound statement)
	///
	/// - Parameter name: The name of the portal or an empty string to use the implicit portal.
	func describePortal(name: String = "") {
		self.transactionStatus = .notReady
		
		var message = WriteBuffer()
		
		message.write(Int8(80))
		message.write(name)
		
		self.write(.describe, message)
	}
	
	/// Excecute a portal (bound statement)
	///
	/// - Parameters:
	///   - portal: The name of the portal or an empty string to use the implicit portal.
	///   - rows: The number of rows to return, or 0 to return them all.
	func execute(portal: String = "", rows: UInt32 = 0) {
		self.transactionStatus = .notReady
		
		var message = WriteBuffer()
		
		message.write(portal)
		message.write(rows)
		
		self.write(.execute, message)
	}
	
	/// Send a sync command to the server
	///
	/// Causes any prepare commands to be processed.
	///
	/// See https://www.postgresql.org/docs/9.3/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY.
	func sync() {
		self.write(.sync, WriteBuffer())
	}
}
