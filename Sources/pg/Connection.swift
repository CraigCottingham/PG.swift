import Foundation
import Dispatch
import Cryptor


func md5(_ text: String) -> String {
    let md5 = Digest(using: .md5)
    _ = md5.update(string: text)
    let digest = md5.final()
    return CryptoUtils.hexString(from: digest)
}


/// The underlying connection to a Postgre server
///
/// You do not normally interact with a connection directly, but instead use `Client` to manage the interaction. This class only handles the low level messages between the client and the server.
public final class Connection {
	/// Errors generated by the connection
	///
	/// - mismatchedDataLengths: The server did not respond with the amount of data is said it would. This is a serious connection error and should result in a disconnect, because it is likely the client and server have gotten out of sync.
	/// - unrecognizedMessage: The server sent a message that the client did not recognize. This is likely an unimplimented feature and can be ignored. The connection will skip the message and move on.
	/// - malformedMessage: The message type was understood, but the message was in a format that the connection did not understand. This should be rare.
	public enum Error: Swift.Error {
		case mismatchedDataLengths
		case malformedMessage
	}
	
	/// Types of authentication requests
	///
	/// - authenticationOK: Sent when the conneciton is authenticated.
	public enum AuthenticationResponse: UInt32 {
		case authenticationOK = 0
		// case kerberosV5 = 2
		case cleartextPassword = 3
		case MD5Password = 5
		// case SCMCredential = 6
	}
	
	/// The query state of the connection
	///
	/// The documentation refer to these by their ASCII character. The rawValue is the ASCII code point.
	///
	/// - notReady: Either the connection has not been established or the connection is currently excecuting a query. The server does not tell us this state, instead we need to set it locally before excecuting a query.
	/// - idle: The server is ready to receive a new query.
	/// - inTransaction: The server is in the middle of a transaction.
	/// - failed: An error occured in a transaction.
	public enum TransactionStatus: UInt8 {
		case notReady
		
		case idle = 73 // I - not in a transaction block
		case inTransaction = 84 // T
		case failed = 69 // E
	}
	
	
	// MARK: - Events
	
	/// Emitted when the connection has authenticated.
	public let loginSuccess = EventEmitter<Void>(name: "PG.Connection.loginSuccess")
	
	/// Emitted when a cleartext password is requested to authenticate.
	public let authenticationCleartextPassword = EventEmitter<Void>(name: "PG.Connection.authenticationCleartextPassword")
	
	/// Emitted when an MD5 hashed password response is requested to authenticate.
	public let authenticationMD5Password = EventEmitter<DataSlice>(name: "PG.Connection.authenticationMD5Password")
	
	
	/// A message (of any type) was received from the server.
	///
	/// This is always called just before the message gets processed.
	public let backendMessageReceived = EventEmitter<BackendMessage>(name: "PG.Connection.backendMessageReceived")
	
	/// A message was received from the server that the connection does not recognize.
	///
	/// This may be because the connection is missing an implimentation for a message type or because the backend has a custom extension. In either case users can extend the capabilities of the connection to handle cursom messages the connection would not otherwise handle.
	public let unrecognizedBackendMessageReceived = EventEmitter<BackendMessage>(name: "PG.Connection.unrecognizedBackendMessageReceived")
	
	
	/// Emitted when a ready for query notification is receieved.
	///
	/// - Note: Note this does not necessarily mean the connection is idle.
	public let readyForQuery = EventEmitter<TransactionStatus>(name: "PG.Connection.readyForQuery")
	
	
	/// Emitted when a row description (the list of field types) is recieved.
	///
	/// This should be sent once per fetch query.
	public let rowDescriptionReceived = EventEmitter<[Field]>(name: "PG.Connection.rowDescriptionReceived")
	
	/// Emitted when a single row is received
	///
	/// This should be sent for each row in a SELECT result.
	public let rowReceived = EventEmitter<[DataSlice?]>(name: "PG.Connection.rowReceived")
	
	/// Emitted when a query has completed processing
	///
	/// Includes the type and result of the query.
	public let commandComplete = EventEmitter<String>(name: "PG.Connection.commandComplete")
	
	/// Emitted when a prepared statement is processed
	///
	/// - Note: parse complete is only sent from the server after a sync or an excecute call.
	public let parseComplete = EventEmitter<Void>(name: "PG.Connection.parseComplete")
	
	/// Emitted when a bind call is completed by the server
	///
	/// - Note: parse complete is only sent from the server after a sync or an excecute call.
	public let bindComplete = EventEmitter<Void>(name: "PG.Connection.bindComplete")
	
	
	/// Emitted when the server sends an error message
	public let errorResponse = EventEmitter<ServerError>(name: "PG.Connection.errorResponse")
	
	/// Emitted when any error occurs, including and error response
	public let error = EventEmitter<Swift.Error>(name: "PG.Connection.error")
	
	
	// MARK: - Initialization
	
	private let queue = DispatchQueue(label: "PG.Connection", qos: .userInteractive)
	
	
	/// The underlying socket connection
	public let socket: ConnectionSocket
	
	
	/// Create a new connection
	///
	/// The streams should be ready for connection, and they should be opened immediately after the connection is created.
	///
	/// - Parameters:
	///   - input: An input stream ready for connection
	///   - output: An output stream ready for connection
	init(socket: ConnectionSocket) {
		self.socket = socket
		
		// start reading messages
		self.read()
	}
	
	deinit {
		self.socket.close()
	}
	
	
	// MARK: - 
	
	/// If the connection has been established
	public var isConnected: Bool {
		return socket.isConnected
	}
	
	/// If the connection has been authenticated with the server
	public private(set) var isAuthenticated: Bool = false
	
	/// Server defined configuration parameters, such as text encoding and date format
	public private(set) var parameters: [String:String] = [:]
	
	/// The process id of the connection, used to cancel queries
	public private(set) var processID: Int32?
	
	/// The secret key of the connection, used to cancel queries
	public private(set) var secretKey: Int32?
	
	/// The state of the server to accept queries
	public fileprivate(set) var transactionStatus: TransactionStatus = .notReady
	
	
	// MARK: - Reading
	
	/// Try to read the next message
	private func read() {
		// because the socket reads new bytes asynchronously, we can just ask it to call us back once it's read in 5 bytes (header size of a pg message)
		// once the server sends the socket data, it will read in the number of bytes we ask for and call us back
		// ince we finish reading in a message, we can ask for the next one and the process starts over
		
		socket.read(length: 1 + 4) { (messageHeader) in
			guard let messageHeader = messageHeader.value else { self.socket.close(); return }
			
			let byte: UInt8 = messageHeader[0..<1].withUnsafeBytes({ $0.pointee })
			let length: UInt32 = UInt32(bigEndian: messageHeader[1..<5].withUnsafeBytes({ $0.pointee })) - 4
			
			self.socket.read(length: Int(length)) { data in
				guard let data = data.value else { self.socket.close(); return }
				
				let messageType = BackendMessageType(rawValue: byte)
				let message = BackendMessage(type: messageType, data: data)
				
				self.queue.async {
					do {
						try self.process(message)
					} catch {
						print("error processing message: \(error)")
						self.error.emit(error)
					}
				}
				
				// we don't need to wait for the message to be processed before reading the next message
				// since we have already read all the data for the current message
				self.read()
			}
		}
	}
	
	private func process(_ message: BackendMessage) throws {
		if #available(OSX 10.12, *) {
			dispatchPrecondition(condition: .onQueue(self.queue))
		}
		var message = message
		
		self.backendMessageReceived.emit(message)
		
		print("processing: \(message)")
		
		switch message.type {
		case BackendMessageType.authentication:
			let rawResponse: UInt32 = try message.read()
			
			if let response = AuthenticationResponse(rawValue: rawResponse) {
				switch response {
				case .authenticationOK:
					self.isAuthenticated = true
					self.loginSuccess.emit()
				case .cleartextPassword:
					authenticationCleartextPassword.emit()
				case .MD5Password:
					let salt = try message.read(length: 4)
					authenticationMD5Password.emit(salt)
				}
			} else {
				
			}
		case BackendMessageType.statusReport:
			let key: String = try message.read()
			let value: String = try message.read()
			
			parameters[key] = value
			
			print("status \(key): \(value)")
		case BackendMessageType.backendKeyData:
			guard message.data.count == 8 else { throw Error.malformedMessage }
			self.processID = try message.read()
			self.secretKey = try message.read()
			
			print("processID: \(processID!) secretKey: \(secretKey!)")
		case BackendMessageType.readyForQuery:
			guard message.data.count == 1 else { throw Error.malformedMessage }
			
			let rawStatus: UInt8 = try message.read()
			self.transactionStatus = TransactionStatus(rawValue: rawStatus) ?? .idle
			
			readyForQuery.emit(self.transactionStatus)
		case BackendMessageType.rowDescription:
			let fieldsCount: UInt16 = try message.read()
			
			let fields: [Field] = try (0..<fieldsCount).map() { _ in
				let field = Field()
				field.name = try message.read()
				field.tableID = try message.read()
				field.columnID = try message.read()
				field.dataTypeID = try OID(message.read())
				field.dataTypeSize = try message.read()
				field.dataTypeModifier = try message.read()
				field.mode = try Field.Mode(rawValue: message.read()) ?? .text
				return field
			}
			
			rowDescriptionReceived.emit(fields)
		case BackendMessageType.commandComplete:
			let commandTag = try message.read() as String
			
			commandComplete.emit(commandTag)
		case BackendMessageType.dataRow:
			let columnCount = try message.read() as UInt16
			
			let rows: [DataSlice?] = try (0..<columnCount).map() { _ in
				let length = try message.read() as Int32
				if length >= 0 {
					return try message.read(length: Int(length))
				} else {
					return nil
				}
			}
			
			rowReceived.emit(rows)
		case BackendMessageType.parseComplete:
			guard message.data.count == 0 else { throw Error.malformedMessage }
			
			parseComplete.emit()
		case BackendMessageType.bindComplete:
			guard message.data.count == 0 else { throw Error.malformedMessage }
			
			bindComplete.emit()
		case BackendMessageType.errorResponse:
			var error = ServerError()
			while message.data.count > 0 {
				let fieldType = try message.read() as UInt8
				guard fieldType != 0 else { break }
				
				guard let field = ServerError.Field(rawValue: fieldType) else { continue }
				let value = try message.read() as String
				
				error.info.append((field, value))
			}
			print("error: \(error)")
			
			self.errorResponse.emit(error)
			self.error.emit(error)
		default:
			self.unrecognizedBackendMessageReceived.emit(message)
			print("unrecognized backend message recieved: \(message)")
		}
	}
}

extension Connection {
	/// Send the initial startup message to the server
	///
	/// - Parameters:
	///   - user: The username for the connection
	///   - database: The database, or nil to connect to the default database
	func sendStartup(user: String, database: String?) {
		var message = FrontendMessage(.startup, capacity: 2 + 2 + 6 + 10 + 24 + 1) // minimum message size
		
		// protocol version
		message.write(3 as Int16)
		message.write(0 as Int16)
		
		message.write("user")
		message.write(user)
		
		if let database = database {
			message.write("database")
			message.write(database)
		}
		
		message.write("client_encoding")
		message.write("'utf-8'")
		
		message.write("")
		
		self.send(message)
	}
	
	
	/// Send a password authentication response
	///
	/// - Parameter password: An authentication response (can be a plain text password or an encrypted authentication response).
	func sendPassword(_ password: String) {
		var message = FrontendMessage(.password) // a typical query size
		message.write(password)
		
		self.send(message)
	}
	
	
	/// Hashes and sends an MD5 authentication response.
	///
	/// - Parameters:
	///   - username: The username used to connect to the server. This must match the one sent in the startup message.
	///   - password: The password to authenticate with.
	///   - salt: The salt returned from the server.
	func sendMD5Authentication(username: String, password: String, salt: DataSlice) {
        let salt = String(salt) ?? ""
		let passwordHash = "md5" + md5(md5(password + username) + salt)
		
		self.sendPassword(passwordHash)
	}
	
	
	/// Excecute a simple query without any bindings
	///
	/// If a query is not going to be prepared and reused, and doesn't have bindings, it can be excecuted faster using a single message instead of the more complicated extended flow.
	///
	/// - Parameter query: A simple query string.
	func simpleQuery(_ query: String) {
		self.transactionStatus = .notReady
		
		var message = FrontendMessage(.simpleQuery, capacity: 30) // a typical query size
		message.write(query)
		
		self.send(message)
	}
	
	/// Prepare a statement with the server
	///
	/// - Parameters:
	///   - name: The name of the statement, or an empty string to use the implicit statement
	///   - query: The query string to prepare, with `$x` for binding placehoders
	///   - types: The low level type ids for the query. Use 0 to not specifiy a type.
	func parse(name: String = "", query: String, types: [OID] = []) {
		self.transactionStatus = .notReady
		
		var message = FrontendMessage(.parseQuery, capacity: 1 + 1 + 2 + (2 * types.count)) // minimum size with an empty name
		
		message.write(name)
		message.write(query)
		message.write(UInt16(types.count))
		for type in types {
			message.write(type.rawValue)
		}
		
		self.send(message)
	}
	
	/// Bind a statement with specific values
	///
	/// - Parameters:
	///   - name: The name of the "portal" (a bound statement) or an empty string to use the implicit portal.
	///   - statementName: The name of the statement to bind to, or an empty string to use the implicit statement.
	///   - parameters: The specific values to bind to. These must matcht the types of the statement.
	///   - resultModes: The mode that the results will be encoded with. Provide a single element to set all the result modes.
	func bind(name: String = "", statementName: String = "", parameters: [PostgresCodable?] = [], resultModes: [Field.Mode] = []) {
		self.transactionStatus = .notReady
		
		var message = FrontendMessage(.bind, capacity: 1 + 1 + 2 + (2 * parameters.count) + 2 + (4 * parameters.count) + 2) // minimum size with empty names and null values
		
		message.write(name)
		message.write(statementName)
		
		message.write(UInt16(parameters.count))
		for parameter in parameters {
			let mode: Field.Mode
			
			if parameter is PostgresBinaryEncodable {
				mode = .binary
			} else {
				mode = .text
			}
			
			message.write(mode.rawValue)
		}
		
		message.write(UInt16(parameters.count))
		for parameter in parameters {
			if let parameter = parameter as? PostgresBinaryEncodable, let data = parameter.pgBinary {
				message.write(Int32(data.count))
				message.write(data)
			} else if let parameter = parameter as? PostgresTextEncodable, let text = parameter.pgText {
				let data = text.data()
				message.write(Int32(data.count))
				message.write(data)
			} else {
				message.write(Int32(-1)) // null
			}
		}
		
		message.write(UInt16(resultModes.count))
		for mode in resultModes {
			message.write(UInt16(mode.rawValue))
		}
		
		self.send(message)
	}
	
	/// Describe a prepared statement
	///
	/// - Parameter name: The name of the statement to bind to, or an empty string to use the implicit statement.
	func describeStatement(name: String = "") {
		self.transactionStatus = .notReady
		
		var message = FrontendMessage(.describe, capacity: 1 + 1) // minimum size assuming an empty name
		
		message.write(Int8(83))
		message.write(name)
		
		self.send(message)
	}
	
	/// Describe a prepared portal (bound statement)
	///
	/// - Parameter name: The name of the portal or an empty string to use the implicit portal.
	func describePortal(name: String = "") {
		self.transactionStatus = .notReady
		
		var message = FrontendMessage(.describe, capacity: 1 + 1) // minimum size assuming an empty name
		
		message.write(Int8(80))
		message.write(name)
		
		self.send(message)
	}
	
	/// Excecute a portal (bound statement)
	///
	/// - Parameters:
	///   - portal: The name of the portal or an empty string to use the implicit portal.
	///   - rows: The number of rows to return, or 0 to return them all.
	func execute(portal: String = "", rows: UInt32 = 0) {
		self.transactionStatus = .notReady
		
		var message = FrontendMessage(.execute, capacity: 1 + 4) // minimum size assuming an empty portal name
		
		message.write(portal)
		message.write(rows)
		
		self.send(message)
	}
	
	/// Send a sync command to the server
	///
	/// Causes any prepare commands to be processed.
	///
	/// See https://www.postgresql.org/docs/9.3/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY.
	func sync() {
		self.send(FrontendMessage(.sync))
	}
}
